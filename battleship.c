/* * File:  battleship.c * Author:  Suzanne Aldrich * Date:  10/27/97 * --------------- * Battleship Game. */#include <stdio.h>#include <stdlib.h>#include "genlib.h"#include "simpio.h"#include "extgraph.h"#include "battlegraphics.h"#include "random.h"#include "strlib.h"#include "sound.h"#define NUM_MISSILES 40#define DATA_FILE "ShipData"#define NUM_DATA_FILES 4#define PICTURE "Logo"typedef enum { horizontal = 0, vertical = 1 } direction;typedef struct {	string	name;	string	color;	string	sound;	int		length;	int 	ships;  //  ships left in class} shipclass;typedef struct {		string		name;	shipclass 	*type; // pointer to ship's shipclass	coord		start;	coord		end;	int			hits; //  number of hit ship cells} ship;typedef struct {	bool	hit;		ship	*occupant;	} cell;typedef struct {	FILE		*initfile;	shipclass 	*fleet;	ship		*convoy;	int			numclasses;	int			numships;  //  total number of ships	int			missiles;	int			hits;	cell		gamegrid[NUM_ROWS][NUM_COLS];} theatre;void Intro(void);void Exit(void);theatre *InitGame(void);void InitClasses(theatre *gt);void InitShips(theatre *gt);void InitGrid(cell *c);void PlaceShips(theatre *gt);bool PositionIsOccupied(theatre *gt, coord pos, int dir, int shiplength);void PlaceOneShip(theatre *gt, coord pos, int dir, ship *currentship);void PlayGame(void);void PlayRound(theatre *gt);main(){	InitGraphics();	Randomize();	Intro();	PlayGame();	Exit();	ExitGraphics();}void Intro(void){		SetWindowTitle("Battleship");	DrawFilledBox(0, 0, GetWindowWidth(), GetWindowHeight(), BOX_COLOR);	MovePen((GetWindowWidth() - GetPictureWidth(PICTURE)) / 2, 		(GetWindowHeight() - GetPictureHeight(PICTURE)) / 2);	DrawNamedPicture(PICTURE);	printf("Please set your monitor to 256 color mode.\n");	printf("Try your luck at Battleship.\n");	printf("The object of the game is to sink all the ships.\n");	printf("Press return to start playing.\n");	GetLine();	DrawFilledBox(0, 0, GetWindowWidth(), GetWindowHeight(), BOX_COLOR);		PlaySoundNamed("Tweetle");	}void Exit(void){	printf("\nEnd of Battleship.\n");	printf("Created by aigeanta@stanford.edu\n");	printf("Press return to exit.\n");	GetLine();}void PlayGame(void) {				theatre *gt = InitGame();			do PlayRound(gt); while (gt->numships && gt->missiles);	if (gt->numships == 0 || (gt->numships == 0 && gt->missiles == 0)) {		DrawPrintfMessage("You win, you lucky bastard.");		PlaySoundNamed("Big Explosion");	}	if (gt->missiles == 0 && gt->numships != 0) {		DrawPrintfMessage("You ran out of missiles, loser.");		PlaySoundNamed("Big Claxton");	}}	void PlayRound(theatre *gt){		coord target;	cell *gridcell;			target = GetLocationChosenByUser();	// check if target is in bounds	if (target.row < 0 || target.col < 0) {		DrawPrintfMessage("Try aiming at the grid, moron.");		PlaySoundNamed("Little Claxton");		return;	}			gt->missiles--;  //  fire a missile	gridcell = &gt->gamegrid[target.row][target.col];		if (gridcell->hit) {		DrawPrintfMessage("You just wasted a missile, numbskull.");		PlaySoundNamed("Missile");	} else if (gridcell->occupant) {		gt->hits++;  //  increment game hit counter		MarkHit(target, gridcell->occupant->type->color);		gridcell->hit = TRUE; //  mark cell hit		DrawPrintfMessage("You just hit something. Lucky shot.");		PlaySoundNamed("Little Explosion");		//  check if ship is sunk		if (++gridcell->occupant->hits == gridcell->occupant->type->length) {			MarkLineAsSunk(gridcell->occupant->start, gridcell->occupant->end, 				gridcell->occupant->type->color);			--gridcell->occupant->type->ships;  //  sink class ship counter			--gt->numships;  //  sink game ship counter			DrawPrintfMessage("You sank %s %s. %d %ss left.", 				gridcell->occupant->type->name,				gridcell->occupant->name,				gridcell->occupant->type->ships,				gridcell->occupant->type->name);			PlaySoundNamed(gridcell->occupant->type->sound);		}			} else {		MarkMiss(target);		gridcell->hit = TRUE;		DrawPrintfMessage("You missed by a long shot.");		PlaySoundNamed("Missile");	}	DrawScore(gt->missiles, gt->numships, (double) gt->hits / (NUM_MISSILES - gt->missiles));	}theatre *InitGame(void){	theatre *gt = (theatre *) GetBlock(sizeof(theatre));		string filename = Concat(DATA_FILE , IntegerToString(RandomInteger(1, NUM_DATA_FILES)));	gt->initfile = fopen(filename, "r");	gt->missiles = NUM_MISSILES;	gt->hits = 0;	InitClasses(gt);		InitShips(gt);	InitGrid(&gt->gamegrid[0][0]);			PlaceShips(gt);			DrawStartingBoard();	DrawScore(gt->missiles, gt->numships, 0.0);	DrawPrintfMessage("Battleship initialized.");	fclose(gt->initfile);	return gt;}void InitClasses(theatre *gt) {	int i;	string line;		line = ReadLine(gt->initfile);		sscanf(line, "Num Classes: %d", &gt->numclasses);	gt->fleet = (shipclass *) GetBlock(gt->numclasses * sizeof(shipclass));	for (i = 0; i < gt->numclasses; i++) {		gt->fleet[i].name = ReadLine(gt->initfile);		gt->fleet[i].length = StringToInteger(ReadLine(gt->initfile));		gt->fleet[i].color = ReadLine(gt->initfile);		gt->fleet[i].sound = ReadLine(gt->initfile);		fgetc(gt->initfile); //  skip over newline		gt->fleet[i].ships = 0;	}	}void InitShips(theatre *gt) {	int i, j;	string line, name;		line = ReadLine(gt->initfile);	sscanf(line, "Num Ships: %d", &gt->numships);			gt->convoy = (ship *) GetBlock(gt->numships * sizeof(ship));	for (i = 0; i < gt->numships; i++) {		gt->convoy[i].name = ReadLine(gt->initfile);		name = ReadLine(gt->initfile);		//  find the ship's class		for (j = 0; j < gt->numclasses; j++)			if (StringEqual(gt->fleet[j].name, name)) break;		gt->fleet[j].ships++;  //  increment number of ships of that class		gt->convoy[i].type = &gt->fleet[j];  //  set pointer to ship's class		gt->convoy[i].hits = 0;		fgetc(gt->initfile);	}}void InitGrid(cell *c) {	int cells = NUM_ROWS * NUM_COLS;			while (cells--) {			c->hit = FALSE;		c->occupant = NULL;			c++;	}}void PlaceShips(theatre *gt){	int i = gt->numships, dir, shiplength;	coord pos;		//  pick a ship to place	while (i--) {		shiplength = gt->convoy[i].type->length;						//  check occupancy for every cell under the potential ship position; escape if clear		do  {			//  proportional orientation algorithm: y / (x + y) + x / (x + y) == 1				//  chooses an orientation more often because grid is larger in that dimension			dir = RandomChance((NUM_COLS-1) / (double) (NUM_ROWS-1 + NUM_COLS-1)) 				? horizontal : vertical;					switch (dir) {			case horizontal:  				pos.row = RandomInteger(0, NUM_ROWS - 1);				pos.col = RandomInteger(0, NUM_COLS - shiplength);				break;			case vertical:				pos.row = RandomInteger(0, NUM_ROWS - shiplength);				pos.col = RandomInteger(0, NUM_COLS - 1);				break;			}		} while (PositionIsOccupied(gt, pos, dir, shiplength)); 		PlaceOneShip(gt, pos, dir, &gt->convoy[i]);	}}bool PositionIsOccupied(theatre *gt, coord pos, int dir, int shiplength){	switch (dir) {	case horizontal:  		while (shiplength--) {			if (gt->gamegrid[pos.row][pos.col++].occupant) {				return (TRUE); //  occupied! try another position			}		}						break;	case vertical:		while (shiplength--) {			if (gt->gamegrid[pos.row++][pos.col].occupant) {				return (TRUE); //  occupied! try another position			}		}		break;	}	return (FALSE);}void PlaceOneShip(theatre *gt, coord pos, int dir, ship *currentship){	int i, shiplength = currentship->type->length;		//  set first coord	currentship->start = pos;		switch (dir) {	//  cycle through cells and point them to their ship	case horizontal:						for (i = 0; i < shiplength; i++) {			gt->gamegrid[pos.row][pos.col + i].occupant = currentship;						}		//  set pos to end position		pos.col += shiplength - 1;					break;	case vertical:			for (i = 0; i < shiplength; i++) {			gt->gamegrid[pos.row + i][pos.col].occupant = currentship;		}		//  set pos to end position		pos.row += shiplength - 1;			break;	}	//  set end coord	currentship->end = pos;}